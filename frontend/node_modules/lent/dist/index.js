/*!
* lent v1.5.4
* (c) 2022 zrrz
* @license MIT
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Http = require('http');
var path = require('path');
var fs = require('fs');
var localPkg = require('local-pkg');
var chokidar = require('chokidar');
var ws = require('ws');
var core = require('@babel/core');
var cheerio = require('cheerio');
var esModuleLexer = require('es-module-lexer');
var MagicString = require('magic-string');
var glob = require('glob');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Http__default = /*#__PURE__*/_interopDefaultLegacy(Http);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);
var cheerio__default = /*#__PURE__*/_interopDefaultLegacy(cheerio);
var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class ExpectLink {
    expect;
    next;
    running(value) {
        const next = async () => {
            if (this.next) {
                await this.next.running(value);
            }
        };
        return this.expect(value, next);
    }
}
class ComposeLink {
    prev = null;
    head = null;
    value;
    constructor(value) {
        this.value = value;
    }
    use(fn) {
        const link = new ExpectLink();
        link.expect = fn;
        if (!this.head)
            this.head = link;
        if (this.prev)
            this.prev.next = link;
        this.prev = link;
        return this;
    }
    run(value) {
        if (value) {
            this.value = value;
        }
        //执行头节点的入口函数
        return this.head.running(this.value);
    }
}

const handleUrl = (fileUrl) => {
    return fileUrl.split('?');
};
const normFileStartWith = (fileName) => {
    if (fileName.startsWith('/')) {
        return `.${fileName}`;
    }
    return fileName;
};
const sliceFileDotName = (str) => {
    if (str && str.startsWith('./')) {
        return str.slice(1);
    }
    return str;
};
const isLentRequest = (str) => {
    if (str.startsWith('/@lent/')) {
        return [str.replace('/@lent/', ''), true];
    }
    return [str, false];
};
const getLastFileName = (fileName) => {
    const lastFileIndex = fileName.lastIndexOf('/');
    const lastFileName = fileName.slice(lastFileIndex);
    const startPath = fileName.slice(0, lastFileIndex);
    return [startPath, lastFileName];
};
const isNodeModuleFile = (fileName) => {
    if (fileName &&
        ['/', './', '../', '.'].every((v) => !fileName.startsWith(v))) {
        return true;
    }
    return false;
};

var etagMiddle = (middlewareHttp, next) => {
    const { http, lentInstance } = middlewareHttp;
    const [requestFileName] = handleUrl(http.req.url);
    const model = lentInstance.depend.getDepend(requestFileName);
    if (model &&
        http.req.headers['if-none-match'] === model.etag
    //  ||
    // 	model.isLentModule === true
    ) {
        http.res.statusCode = 304;
        return http.res.end();
    }
    if (requestFileName.endsWith('.map')) {
        return http.res.end();
    }
    middlewareHttp.mate.requestFileName = requestFileName;
    next();
};

var routerMiddle = (middlewareHttp, next) => {
    const { http, lentInstance, mate } = middlewareHttp;
    const item = lentInstance.router
        .getRouters()
        .find((v) => v.path === mate.requestFileName);
    const plugins = lentInstance.plugin;
    if (item) {
        const indexHtmlPlugin = plugins
            .getPlugins()
            .find((v) => v.name === 'indexHtmlAddClientPlugin');
        if (indexHtmlPlugin && mate.requestFileName === '/') {
            return http.res.end(indexHtmlPlugin.transform(item?.handler(http.req, http.res).toString(), {
                filePath: 'index.html',
                requestUrl: mate.requestFileName,
                isLentModule: true,
                isModulesFile: false
            }));
        }
        return Promise.resolve(item?.handler(http.req, http.res)).then((v) => http.res.end(v));
    }
    next();
};

const whiteNames = ['client'];
/**
 * 这块需要重点重构
 */
const isHaveFile = async (requireName, rawRequireName, lentHttpInstance) => {
    let fileRoot = lentHttpInstance.config.root;
    let isModulesFile = false;
    // eslint-disable-next-line prefer-const
    let [convertFileName, isLentStart] = isLentRequest(rawRequireName);
    if (isLentStart && whiteNames.some((v) => convertFileName === v)) {
        fileRoot = __dirname;
        convertFileName += '.js';
    }
    else if (isLentStart) {
        fileRoot = process.cwd();
        try {
            const filePackage = await localPkg.getPackageInfo(convertFileName);
            const fileRoot = filePackage.packageJson.module || filePackage.packageJson.main;
            if (filePackage.packageJson.module) {
                isModulesFile = true;
            }
            convertFileName = path__default["default"].join('/node_modules', convertFileName, fileRoot);
        }
        catch (e) {
            console.warn(`[lent warn] no find module ${convertFileName} do you have install ?`);
            return ['', false, false];
        }
    }
    else {
        convertFileName = requireName;
    }
    const filePath = path__default["default"].join(fileRoot, convertFileName);
    if (fs__default["default"].existsSync(filePath)) {
        return [filePath, isLentStart, isModulesFile];
    }
    return ['', isLentStart, false];
};
const findFile = async (requireName, fileExit, lentHttpInstance) => {
    const [f, isLentModule, isModulesFile] = await isHaveFile(requireName, requireName, lentHttpInstance);
    if (f)
        return [f, isLentModule, isModulesFile];
    for (const exitName of fileExit) {
        const [f, isLentModule] = await isHaveFile(requireName + exitName, requireName, lentHttpInstance);
        if (f) {
            return [f, isLentModule, isModulesFile];
        }
    }
    return ['', isLentModule, isModulesFile];
};
const transform = async (requestFileName, plugins, lentHttpInstance) => {
    let fileData = '';
    const [filePath, isLentModule, isModulesFile] = await findFile(requestFileName, lentHttpInstance.config.extensions, lentHttpInstance);
    const filterPlugins = plugins().filter((v) => {
        if (requestFileName.endsWith(v.exit) || filePath.endsWith(v.exit)) {
            return true;
        }
        else if (v.exits?.some((vv) => requestFileName.includes(vv) || filePath.endsWith(vv))) {
            return true;
        }
    });
    if (filePath) {
        fileData = fs__default["default"].readFileSync(filePath).toString();
    }
    const fileUrl = {
        filePath,
        requestUrl: requestFileName,
        isLentModule: isLentModule,
        isModulesFile
    };
    const reduces = (prev, next) => {
        return prev.then((value) => next.transform(value, fileUrl, lentHttpInstance));
    };
    //这里可以单独抽离为一个库
    return plugins()
        .filter((v) => v.enforce === 'pre')
        .reduce(reduces, Promise.resolve(fileData))
        .then((fileSource) => filterPlugins.reduce(reduces, Promise.resolve(fileSource)))
        .then((fileSource) => {
        return plugins()
            .filter((v) => v.enforce === 'post')
            .reduce(reduces, Promise.resolve(fileSource));
    })
        .catch((e) => {
        console.log('[lent error]', e);
    });
};

var transformMiddle = (middlewareHttp, next) => {
    const { http, lentInstance, mate } = middlewareHttp;
    const plugins = lentInstance.plugin;
    transform(mate.requestFileName, plugins.getPlugins, lentInstance).then((transformValue) => {
        const fileValue = transformValue || '';
        const etag = lentInstance.depend.getDepend(mate.requestFileName)?.etag;
        http.res.setHeader('content-Type', 'text/javascript');
        if (etag) {
            http.res.setHeader('Etag', etag);
        }
        http.res.end(fileValue);
    });
    next();
};

const pkg = require(path__default["default"].resolve(__dirname, `../package.json`));
const router = () => {
    const routers = new Set();
    return {
        addRouter(router) {
            routers.add(router);
        },
        getRouters() {
            return [...routers];
        }
    };
};
const createHttp = (lentInstance) => {
    const http = Http__default["default"].createServer();
    return {
        http: () => http,
        start() {
            http.on('upgrade', (req, socket, head) => {
                lentInstance.socket.webSocket.handleUpgrade(req, socket, head, (ws) => {
                    lentInstance.socket.webSocket.emit('connection', ws, req);
                });
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const middleware = new ComposeLink();
            middleware.use(etagMiddle).use(routerMiddle);
            lentInstance.config?.middle?.forEach((v) => middleware.use(v));
            middleware.use(transformMiddle);
            http
                .on('request', (req, res) => {
                middleware.run({
                    lentInstance,
                    http: {
                        req,
                        res
                    },
                    mate: {}
                });
            })
                .listen(lentInstance.config.port, () => {
                console.log(`lent v${pkg.version} dev server running at:`);
                console.log(`> Local: http://localhost:${lentInstance.config.port}/`);
                console.log(`> running time ${Date.now() - lentInstance.performance.startTime}ms`);
            });
        }
    };
};

const createWatchFile = (l) => {
    const watcher = chokidar__default["default"]
        .watch([], {
        persistent: true
    })
        .on('change', (path) => l.watchFileEvent.emit('change', path));
    return watcher;
};
const handleWatchFileEvent = () => {
    const fileWatchEvent = new Map();
    return {
        on(eventName, fileCallback) {
            if (!fileWatchEvent.has(eventName)) {
                fileWatchEvent.set(eventName, [fileCallback]);
            }
            else {
                const fileRegister = fileWatchEvent.get(eventName);
                if (!fileRegister.some((v) => v.filePath === fileCallback.filePath)) {
                    fileWatchEvent.get(eventName).push(fileCallback);
                }
            }
        },
        emit(eventName, path) {
            const event = fileWatchEvent.get(eventName);
            if (event) {
                event.forEach((v) => {
                    if (v.filePath === path)
                        v.callback();
                });
            }
        }
    };
};
const addFileChange = (l, fileUrl, callback) => {
    l.watchFileEvent.on('change', {
        filePath: fileUrl.filePath,
        callback: () => {
            console.log(`[lent] update file ${fileUrl.requestUrl}`);
            callback();
        }
    });
    l.watch.add(fileUrl.filePath);
};

const createLentModuleDepend = (m) => {
    return {
        etag: '',
        requestUrl: '',
        importFile: [],
        hash: '',
        isLentModule: true,
        isModulesFile: false,
        ...m
    };
};
const depends = () => {
    const dependGraph = new Map();
    return {
        getGraph: () => dependGraph,
        getDepend: (fileName) => dependGraph.get(fileName),
        addDepend(fileName, lentModule) {
            if (!dependGraph.has(fileName)) {
                dependGraph.set(fileName, lentModule);
            }
        }
    };
};
const getDependsParent = (moduleFileName, depends) => {
    const depMap = depends.getGraph();
    // const findParents = [];
    const walkDepend = (fileName) => {
        for (const [modulePath, moduleValue] of depMap) {
            const [lastStartPath, lastFileName] = getLastFileName(fileName);
            const [lastModulePath] = getLastFileName(modulePath);
            const covFileName = lastModulePath === lastStartPath ? lastFileName : fileName;
            if (modulePath !== fileName) {
                const haveParent = moduleValue.importFile.some((i) => i.n === normFileStartWith(covFileName));
                if (haveParent) {
                    // findParents.unshift(modulePath);
                    return [...walkDepend(modulePath), modulePath];
                }
            }
        }
        return [];
    };
    return walkDepend(moduleFileName);
    // return findParents;
};
const setDependsAddHash = (fileNames, depends) => {
    fileNames.forEach((v) => {
        const fileDepend = depends.getDepend(v);
        if (fileDepend) {
            fileDepend.hash = Date.now().toString();
        }
    });
};

const createWss = () => {
    const webSocket = new ws.WebSocketServer({
        noServer: true
    });
    const sendSocket = (v) => {
        webSocket.clients.forEach((socket) => {
            socket.send(JSON.stringify(v));
        });
    };
    webSocket.on('connection', (socket) => {
        socket.send(JSON.stringify({ type: 'connected' }));
        // socket.on("message", (msg) => {})
    });
    return {
        webSocket,
        sendSocket
    };
};

const transformSyncCode = (code, otherPresets = [], sourceFileName = '') => {
    return core.transformSync(code, {
        sourceMaps: 'inline',
        sourceFileName,
        presets: [['babel-preset-typescript'], ...otherPresets]
    }).code;
};
const handleNodeModulePlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleNodeModulePlugin',
        enforce: 'post',
        async transform(v, file) {
            if (file.isLentModule && file.isModulesFile) {
                return v;
            }
            return transformSyncCode(v, [], path__default["default"].join(process.cwd(), file.filePath));
        }
    });
};

const getConfig = (lentHttpInstance) => {
    const cwd = process.cwd();
    const configPaths = [
        path__default["default"].join(cwd, '/lent.config.js'),
        path__default["default"].join(cwd, '/lent.config.ts')
    ];
    const defineConfig = configPaths.find((configPath) => fs__default["default"].existsSync(configPath));
    let config = {};
    if (defineConfig) {
        const extension = path__default["default"].extname(defineConfig);
        const defaultLoader = require.extensions[extension];
        require.extensions[extension] = (module, requiredFileName) => {
            if (requiredFileName === defineConfig) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                module._compile(transformSyncCode(fs__default["default"].readFileSync(defineConfig), [
                    [
                        '@babel/preset-env',
                        {
                            targets: {
                                node: 'current'
                            }
                        }
                    ]
                ]), requiredFileName);
            }
            else {
                if (defaultLoader) {
                    defaultLoader(module, requiredFileName);
                }
            }
        };
        const requireConfig = require(defineConfig);
        config = requireConfig.default || requireConfig;
    }
    if (config.plugin) {
        config.plugin(lentHttpInstance);
    }
    return {
        root: cwd,
        port: 3000,
        extensions: ['.js', '.ts', '.css'],
        ...config
    };
};

const indexRouterPlugin = (l) => {
    l.router.addRouter({
        method: 'GET',
        path: '/',
        handler() {
            const indexPath = path__default["default"].join(l.config.root, './index.html');
            l.depend.addDepend(indexPath, createLentModuleDepend({
                importFile: []
            }));
            addFileChange(l, {
                filePath: indexPath,
                requestUrl: indexPath,
                isLentModule: true,
                isModulesFile: false
            }, () => {
                l.socket.sendSocket({
                    hotModule: {
                        fileName: indexPath,
                        parent: []
                    },
                    hot: true
                });
            });
            return fs__default["default"].readFileSync(indexPath);
        }
    });
};

const handleCssPlugin = (l) => {
    l.plugin.addPlugins({
        exit: '.css',
        name: 'handleCssPlugin',
        transform: (v, fileName) => {
            return `
                const styles =  [...document.querySelectorAll("style")];
                const style = styles.find(v=>v.title === '${fileName.requestUrl}');
                if(style){
                    style.innerHTML = '${v.toString().replace(/\n|\r/g, '')}';
                }else{
                    const style = document.createElement('style');
                    style.setAttribute('type', 'text/css');
                    style.title = '${fileName.requestUrl}';
                    style.innerHTML = '${v.toString().replace(/\n|\r/g, '')}';
                    document.head.appendChild(style);
                }
                if (import.meta.hot) {
                    import.meta.hot.accept(() => {});
                }
                `;
        }
    });
};

const indexHtmlAddClientPlugin = (l) => {
    l.plugin.addPlugins({
        name: 'indexHtmlAddClientPlugin',
        transform(v) {
            const $ = cheerio__default["default"].load(v);
            $('head').append(`<script type='module' src='/@lent/client' />`);
            return $.html();
        }
    });
};

const handleFileImportPlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleFileImportPlugin',
        exits: ['.js', '.ts', '.tsx', '.mjs', '.mts'],
        async transform(v, file, i) {
            await esModuleLexer.init;
            const [imports] = esModuleLexer.parse(v);
            const dependModule = i.depend.getDepend(file.requestUrl);
            dependModule.importFile = [...imports];
            const s = new MagicString__default["default"](v);
            imports.forEach((importItem) => {
                const childModule = i.depend.getDepend(sliceFileDotName(importItem.n));
                if (childModule && childModule.hash) {
                    s.overwrite(importItem.s, importItem.e, `${importItem.n}?t=${childModule.hash}`);
                }
                if (isNodeModuleFile(importItem.n)) {
                    s.overwrite(importItem.s, importItem.e, `/@lent/${importItem.n}`);
                }
            });
            return s.toString();
        }
    });
};

const handleFileWatchPlugin = (l) => {
    const setFileEtag = (requestUrl, isSend) => {
        const dependModule = l.depend.getDepend(requestUrl);
        dependModule.etag = Date.now().toString();
        if (isSend) {
            const moduleParent = getDependsParent(requestUrl, l.depend);
            if (moduleParent.length) {
                setDependsAddHash([...moduleParent.slice(1), requestUrl], l.depend);
            }
            l.socket.sendSocket({
                hotModule: {
                    fileName: requestUrl,
                    parent: moduleParent
                },
                hot: true
            });
        }
    };
    l.plugin.addPlugins({
        name: 'handleFileWatchPlugin',
        enforce: 'post',
        transform: (v, file, i) => {
            const dependModule = i.depend.getDepend(file.requestUrl);
            setFileEtag(file.requestUrl, false);
            if (dependModule && file.filePath && !file.isLentModule) {
                addFileChange(i, file, () => {
                    setFileEtag(file.requestUrl, true);
                });
            }
            return v;
        }
    });
};

const handleSocketPortPlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleSocketPortPlugin',
        enforce: 'post',
        transform(fileData, fileUrl, v) {
            if (fileUrl.requestUrl.includes('client')) {
                return fileData.replace('replace_socket_url', v.config.port.toString());
            }
            return fileData;
        }
    });
};

const handleCreateLentFileModulePlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleCreateLentFileModulePlugin',
        enforce: 'pre',
        transform(v, file, i) {
            i.depend.addDepend(file.requestUrl, createLentModuleDepend({
                requestUrl: file.requestUrl,
                isLentModule: file.isLentModule
            }));
            return v;
        }
    });
};

const handleInjectClientPlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleFileImportPlugin',
        enforce: 'post',
        transform(v, file) {
            if (!file.isLentModule &&
                ['.js', '.ts', '.tsx', '.mjs', '.mts', '.css'].some((v) => file.filePath.endsWith(v))) {
                const ms = new MagicString__default["default"](v);
                ms.prepend(`import { createHotContext } from "/@lent/client";import.meta.hot = createHotContext('${file.requestUrl}');`);
                ms.prepend("var process = {env:{NODE_ENV:'development'}};");
                return ms.toString();
            }
            return v;
        }
    });
};

const handleGlobPlugin = (l) => {
    l.plugin.addPlugins({
        name: 'handleGlobPlugin',
        exits: ['.js', '.ts', '.tsx', '.mjs', '.mts'],
        transform(v, file, i) {
            if (v) {
                const globIndex = v.indexOf('import.meta.glob(');
                if (globIndex > -1) {
                    const endIndex = v.indexOf(`)`, globIndex);
                    const globStart = globIndex + 'import.meta.glob('.length + 1;
                    const pattern = v.slice(globStart, endIndex - 1);
                    const files = glob.glob.sync(pattern, {
                        cwd: path__default["default"].join(process.cwd(), i.config.root),
                        ignore: ['**/node_modules/**']
                    });
                    const overwriteCode = new MagicString__default["default"]('');
                    overwriteCode.prepend('{');
                    files.forEach((v) => {
                        overwriteCode.append(`'${v}':()=>import('${v}'),`);
                    });
                    overwriteCode.append('}');
                    const s = new MagicString__default["default"](v);
                    s.overwrite(globIndex, endIndex + 1, overwriteCode.toString());
                    return s.toString();
                }
            }
            return v;
        }
    });
};

const plugins = () => {
    const plugins = [];
    return {
        addPlugins(p) {
            plugins.push(p);
        },
        getPlugins() {
            return plugins;
        }
    };
};
const preCompose = () => {
    return [
        indexRouterPlugin,
        indexHtmlAddClientPlugin,
        handleCssPlugin,
        handleFileImportPlugin,
        handleCreateLentFileModulePlugin,
        handleFileWatchPlugin,
        handleNodeModulePlugin,
        handleInjectClientPlugin,
        handleSocketPortPlugin,
        handleGlobPlugin
    ];
};
const applyComposePlugin = (l) => {
    preCompose().forEach((p) => p(l));
};

// eslint-disable-next-line @typescript-eslint/no-empty-function
const defineLentConfig = (l) => {
    return l;
};

const lent = () => {
    const lentInstance_ = {
        performance: {
            startTime: Date.now()
        },
        watchFileEvent: handleWatchFileEvent(),
        router: router(),
        plugin: plugins(),
        depend: depends(),
        config: null,
        socket: null,
        watch: null,
        http: null
    };
    lentInstance_.watch = createWatchFile(lentInstance_);
    lentInstance_.socket = createWss();
    lentInstance_.http = createHttp(lentInstance_);
    lentInstance_.config = getConfig(lentInstance_);
    applyComposePlugin(lentInstance_);
    return lentInstance_;
};
if (process.env.LENT_DEV) {
    lent().http.start();
}

exports.defineLentConfig = defineLentConfig;
exports.lent = lent;
